"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const utils_fs_1 = require("@ionic/utils-fs");
const debug_1 = tslib_1.__importDefault(require("debug"));
const path_1 = tslib_1.__importDefault(require("path"));
const error_1 = require("./error");
const image_1 = require("./image");
const resources_1 = require("./resources");
const debug = debug_1.default('cordova-res:platform');
exports.PLATFORMS = ["android" /* ANDROID */, "ios" /* IOS */];
async function run(platform, resourcesDirectory, options, errstream) {
    debug('Running %s platform with options: %O', platform, options);
    const resources = [];
    const sources = [];
    const adaptiveResult = await runAdaptive(platform, resourcesDirectory, options["adaptive-icon" /* ADAPTIVE_ICON */], errstream);
    if (adaptiveResult && adaptiveResult.resources.length > 0) {
        resources.push(...adaptiveResult.resources);
        sources.push(...adaptiveResult.sources);
    }
    else {
        const iconResult = await runType("icon" /* ICON */, platform, resourcesDirectory, options["icon" /* ICON */]);
        if (iconResult) {
            resources.push(...iconResult.resources);
            sources.push(iconResult.source);
        }
    }
    const splashResult = await runType("splash" /* SPLASH */, platform, resourcesDirectory, options["splash" /* SPLASH */]);
    if (splashResult) {
        resources.push(...splashResult.resources);
        sources.push(splashResult.source);
    }
    return {
        resources,
        sources,
    };
}
exports.run = run;
async function runAdaptive(platform, resourcesDirectory, options, errstream) {
    if (platform !== "android" /* ANDROID */ || !options) {
        return;
    }
    try {
        return await runAdaptiveType(platform, resourcesDirectory, options, errstream);
    }
    catch (e) {
        debug('Error with adaptive icons: %O', e);
        if (!(e instanceof error_1.ResolveSourceImageError)) {
            throw e;
        }
    }
}
exports.runAdaptive = runAdaptive;
async function runType(type, platform, resourcesDirectory, options, errstream) {
    if (!options) {
        return;
    }
    debug('Building %s resources for %s platform', type, platform);
    const source = await image_1.resolveSourceImage(type, options.sources, errstream);
    debug('Using %O for %s source image for %s', source.image.src, type, platform);
    const config = resources_1.getResourcesConfig(platform, type);
    const resources = await Promise.all(config.resources.map(async (resource) => (Object.assign({}, resource, await generateImageResource(type, platform, resourcesDirectory, config, source.image, resource, "src" /* SRC */, errstream)))));
    return {
        resources,
        source,
    };
}
exports.runType = runType;
async function runAdaptiveType(platform, resourcesDirectory, options, errstream) {
    if (platform !== "android" /* ANDROID */) {
        throw new error_1.BadInputError(`Adaptive icons can only be generated for "${"android" /* ANDROID */}" platform (not "${platform}")`);
    }
    if (options.foreground.sources.length === 0 || options.background.sources.length === 0) {
        throw new error_1.BadInputError('Adaptive icons require sources for both foreground and background.');
    }
    const foregroundSources = options.foreground.sources
        .map(source => typeof source === 'string' ? source : source.type === "raster" /* RASTER */ ? source.src : undefined)
        .filter((source) => typeof source === 'string');
    if (foregroundSources.length === 0) {
        throw new error_1.BadInputError('Adaptive icon foreground source must be an image.');
    }
    debug('Building %s resources for %s platform', "adaptive-icon" /* ADAPTIVE_ICON */, platform);
    const { resources: foregroundResources, source: foregroundSource } = await runAdaptiveSource(resourcesDirectory, foregroundSources, "foreground" /* FOREGROUND */, errstream);
    const resolvedBackgroundSource = await resolveSource("adaptive-icon" /* ADAPTIVE_ICON */, "background" /* BACKGROUND */, options.background.sources, errstream);
    const config = resources_1.getResourcesConfig("android" /* ANDROID */, "adaptive-icon" /* ADAPTIVE_ICON */);
    const resources = resolvedBackgroundSource.type === "raster" /* RASTER */
        ? await Promise.all(foregroundResources.map(async (resource) => {
            const { background, format, width, height } = resource;
            if (!background || !format || !width || !height) {
                throw new error_1.BadInputError(`Bad adaptive icon image schema: (background: ${background}, format: ${format}, width: ${width}, height: ${height})`);
            }
            const backgroundResource = await generateImageResource("adaptive-icon" /* ADAPTIVE_ICON */, "android" /* ANDROID */, resourcesDirectory, config, resolvedBackgroundSource.image, { src: background, format, width, height }, "background" /* BACKGROUND */, errstream);
            return Object.assign({}, resource, { background: backgroundResource.background });
        }))
        : foregroundResources.map(resource => (Object.assign({}, resource, { background: '@color/background' })));
    return {
        resources,
        sources: [foregroundSource, resolvedBackgroundSource],
    };
}
exports.runAdaptiveType = runAdaptiveType;
async function resolveSource(type, name, sources, errstream) {
    for (const source of sources) {
        if (typeof source === 'string' || source.type === "raster" /* RASTER */) {
            const src = typeof source === 'string' ? source : source.src;
            try {
                return await image_1.readSourceImage(type, src);
            }
            catch (e) {
                image_1.debugSourceImage(src, e, errstream);
            }
        }
        else if (source.type === "color" /* COLOR */) {
            const color = source.color.toUpperCase();
            if (!color.match(resources_1.COLOR_REGEX)) {
                throw new error_1.BadInputError(`Color ${color} does not match regex ${resources_1.COLOR_REGEX}.`);
            }
            return { type: "color" /* COLOR */, name, color };
        }
    }
    throw new error_1.BadInputError(`Missing source for "${type}" (sources: ${sources.join(', ')})`);
}
exports.resolveSource = resolveSource;
async function runAdaptiveSource(resourcesDirectory, sources, type, errstream) {
    const source = await image_1.resolveSourceImage("adaptive-icon" /* ADAPTIVE_ICON */, sources);
    debug('Using %O for %s source image for %s', source.image.src, "adaptive-icon" /* ADAPTIVE_ICON */, "android" /* ANDROID */);
    const config = resources_1.getResourcesConfig("android" /* ANDROID */, "adaptive-icon" /* ADAPTIVE_ICON */);
    const resources = await Promise.all(config.resources.map(async (resource) => (Object.assign({}, resource, await generateImageResource("adaptive-icon" /* ADAPTIVE_ICON */, "android" /* ANDROID */, resourcesDirectory, config, source.image, Object.assign({}, resource, { src: resource[type] }), type, errstream)))));
    return {
        resources,
        source,
    };
}
exports.runAdaptiveSource = runAdaptiveSource;
async function generateImageResource(type, platform, resourcesDirectory, config, image, schema, key, errstream) {
    const { pipeline, metadata } = image;
    const { src, format, width, height } = schema;
    const dest = path_1.default.join(resourcesDirectory, src);
    await utils_fs_1.ensureDir(path_1.default.dirname(dest));
    await image_1.generateImage({ src: dest, format, width, height }, pipeline.clone(), metadata, errstream);
    return {
        type,
        format,
        width,
        height,
        srckey: key,
        [key]: dest,
        platform,
        nodeName: config.nodeName,
        nodeAttributes: config.nodeAttributes,
    };
}
exports.generateImageResource = generateImageResource;
function validatePlatforms(platforms) {
    const result = [];
    for (const platform of platforms) {
        if (!isSupportedPlatform(platform)) {
            throw new error_1.BadInputError(`Unsupported platform: ${platform}`);
        }
        result.push(platform);
    }
    return result;
}
exports.validatePlatforms = validatePlatforms;
function isSupportedPlatform(platform) {
    return exports.PLATFORMS.includes(platform);
}
exports.isSupportedPlatform = isSupportedPlatform;
